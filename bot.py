import os
import threading
import statistics
from datetime import datetime

from telethon import TelegramClient, events
from telethon.errors import UsernameNotOccupiedError
from telethon.tl.types import User
from telethon.tl.functions.users import GetFullUserRequest
import http.server
import socketserver

# â”€â”€â”€ ĞŸĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğµ Ğ¾ĞºÑ€ÑƒĞ¶ĞµĞ½Ğ¸Ñ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
API_ID    = int(os.environ['API_ID'])
API_HASH  = os.environ['API_HASH']
BOT_TOKEN = os.environ['BOT_TOKEN']
PORT      = int(os.environ.get('PORT', 8000))

# â”€â”€â”€ ĞšĞ¾Ğ½ÑÑ‚Ğ°Ğ½Ñ‚Ñ‹ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
HISTORY_LIMIT = 100  # ÑĞºĞ¾Ğ»ÑŒĞºĞ¾ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ñ… ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ

# â”€â”€â”€ HTTP-ÑĞµÑ€Ğ²ĞµÑ€ Ğ´Ğ»Ñ Render (ping) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class PingHandler(http.server.BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.end_headers()
        self.wfile.write(b"OK")
    def log_message(self, fmt, *args):
        return  # Ğ±ĞµĞ· Ğ»Ğ¾Ğ³Ğ¾Ğ²

def run_http():
    with socketserver.TCPServer(("", PORT), PingHandler) as httpd:
        httpd.serve_forever()

# â”€â”€â”€ Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Telethon â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
client = TelegramClient('bot_session', API_ID, API_HASH)
client.start(bot_token=BOT_TOKEN)

# â”€â”€â”€ ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº /start â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
@client.on(events.NewMessage(pattern=r'^/start$'))
async def start_handler(event):
    await event.reply(
        "ĞŸÑ€Ğ¸Ğ²ĞµÑ‚! Ğ¯ ÑƒĞ¼ĞµÑ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑÑ‚ÑŒ Ğ¿ÑƒĞ±Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ¾Ğ² Telegram.\n"
        "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹: /info <username_or_link>"
    )

# â”€â”€â”€ Ğ¡Ğ±Ğ¾Ñ€ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def fetch_info(entity):
    # Ğ±Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğµ Ğ¿Ğ¾Ğ»Ñ
    info = {
        'type':     entity.__class__.__name__,
        'id':       entity.id,
        'username': getattr(entity, 'username', None),
        'name':     getattr(entity, 'title', None) or f"{getattr(entity,'first_name','')} {getattr(entity,'last_name','')}".strip()
    }

    # Ğ´Ğ»Ñ ĞºĞ°Ğ½Ğ°Ğ»Ğ¾Ğ²/Ğ³Ñ€ÑƒĞ¿Ğ¿: Ñ‡Ğ¸ÑĞ»Ğ¾ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ²
    try:
        info['subscribers'] = (await client.get_participants(entity, limit=0)).total
    except:
        info['subscribers'] = None

    # Ğ´Ğ»Ñ Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ñ‹Ñ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ â€” Ğ´Ğ¾Ğ¿. Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
    if isinstance(entity, User):
        full = await client(GetFullUserRequest(entity.id))
        # Telethon ĞºĞ»Ğ°Ğ´Ñ‘Ñ‚ Ğ¿Ğ¾Ğ´Ñ€Ğ¾Ğ±Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ² Ğ°Ñ‚Ñ€Ğ¸Ğ±ÑƒÑ‚ full_user  [oai_citation:0â€¡Ğ¥Ğ°Ğ±Ñ€ Q&A â€” Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑÑ‹ Ğ¸ Ğ¾Ñ‚Ğ²ĞµÑ‚Ñ‹](https://qna.habr.com/q/1251348)
        data = getattr(full, 'full_user', full)

        info.update({
            'is_bot':       entity.bot,
            'is_verified':  getattr(data, 'bot_info', None) is not None,
            'phone':        getattr(entity, 'phone', None),
            'about':        getattr(data, 'about', ''),
            'about_len':    len(getattr(data, 'about', '')),
            'status':       str(getattr(entity, 'status', '')),
            'photos_count': (await client.get_profile_photos(entity, limit=0)).total,
            'common_chats': getattr(data, 'common_chats_count', None),
        })

    # Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµĞ¼ Ğ´Ğ°Ñ‚Ñƒ Ğ¿ĞµÑ€Ğ²Ğ¾Ğ³Ğ¾ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ (Ğ¿Ñ€Ğ¸Ğ±Ğ»Ğ¸Ğ·Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ Ğ´Ğ°Ñ‚Ğ° ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ)
    first_msg = None
    async for m in client.iter_messages(entity, limit=1, reverse=True):
        first_msg = m
    info['creation_date'] = first_msg.date.strftime('%Y-%m-%d') if first_msg else None

    # Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ· Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ñ… HISTORY_LIMIT ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹
    msgs = []
    async for m in client.iter_messages(entity, limit=HISTORY_LIMIT):
        if m.date and m.message:
            msgs.append(m)
    info['total_posts'] = len(msgs)

    # ÑÑ€ĞµĞ´Ğ½ĞµĞµ Ğ¸ Ğ¼ĞµĞ´Ğ¸Ğ°Ğ½Ğ° Ğ¿Ğ¾ÑÑ‚Ğ¾Ğ² Ğ² Ğ´ĞµĞ½ÑŒ
    days = [m.date.date() for m in msgs]
    counts = {}
    for d in days:
        counts[d] = counts.get(d, 0) + 1
    per_day = list(counts.values())
    info['avg_per_day']    = round(statistics.mean(per_day), 2) if per_day else 0
    info['median_per_day'] = statistics.median(per_day) if per_day else 0

    # ĞµÑÑ‚ÑŒ Ğ»Ğ¸ Ñ€ĞµĞ°ĞºÑ†Ğ¸Ğ¸
    total_reacts = sum(
        sum(r.count for r in m.reactions.reactions)
        for m in msgs if m.reactions
    )
    info['has_reactions'] = total_reacts > 0

    return info

# â”€â”€â”€ ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº /info â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
@client.on(events.NewMessage(pattern=r'/info(?: |$)(.+)'))
async def handler(event):
    target = event.pattern_match.group(1).strip()
    if target.startswith('http'):
        target = target.rstrip('/').split('/')[-1]

    try:
        entity = await client.get_entity(target)
    except UsernameNotOccupiedError:
        return await event.reply("âŒ ĞĞµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ¸Ğ»Ğ¸ ĞºĞ°Ğ½Ğ°Ğ».")
    except Exception as e:
        return await event.reply(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {e}")

    await event.reply("ğŸ” Ğ¡Ğ¾Ğ±Ğ¸Ñ€Ğ°Ñ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñâ€¦")
    info = await fetch_info(entity)

    lines = [f"â€¢ {k}: {v}" for k, v in info.items()]
    await event.reply("ğŸ“Š Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ:\n" + "\n".join(lines))

# â”€â”€â”€ Ğ—Ğ°Ğ¿ÑƒÑĞº â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def main():
    threading.Thread(target=run_http, daemon=True).start()
    print("Ğ‘Ğ¾Ñ‚ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½â€¦")
    client.run_until_disconnected()

if __name__ == '__main__':
    main()
