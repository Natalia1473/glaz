import os
import threading
import statistics
from datetime import datetime

from telethon import TelegramClient, events
from telethon.errors import UsernameNotOccupiedError
from telethon.tl.types import User
from telethon.tl.functions.users import GetFullUserRequest

import http.server
import socketserver

# â”€â”€â”€ ĞŸĞ•Ğ Ğ•ĞœĞ•ĞĞĞ«Ğ• ĞĞšĞ Ğ£Ğ–Ğ•ĞĞ˜Ğ¯ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
API_ID   = int(os.environ['API_ID'])
API_HASH = os.environ['API_HASH']
PORT     = int(os.environ.get('PORT', 8000))

# â”€â”€â”€ HTTP-ÑĞµÑ€Ğ²ĞµÑ€ Ğ´Ğ»Ñ Render (Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ±Ñ‹Ğ»Ğ¾ Ğ¿Ñ€Ğ¾ÑĞ»ÑƒÑˆĞ¸Ğ²Ğ°ĞµĞ¼Ğ¾Ğµ Ğ¿Ğ¾Ñ€Ñ‚) â”€â”€â”€â”€â”€â”€â”€
class PingHandler(http.server.BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.end_headers()
        self.wfile.write(b"OK")
    def log_message(self, fmt, *args):
        pass

def run_http():
    with socketserver.TCPServer(("", PORT), PingHandler) as srv:
        srv.serve_forever()

# â”€â”€â”€ Ğ˜ĞĞ˜Ğ¦Ğ˜ĞĞ›Ğ˜Ğ—ĞĞ¦Ğ˜Ğ¯ Ğ¢Ğ•Ğ›Ğ•Ğ¤ĞĞĞĞĞ“Ğ ĞšĞ›Ğ˜Ğ•ĞĞ¢Ğ (ĞŸĞĞ›Ğ¬Ğ—ĞĞ’ĞĞ¢Ğ•Ğ›Ğ¬Ğ¡ĞšĞĞ¯ Ğ¡Ğ•Ğ¡Ğ¡Ğ˜Ğ¯) â”€â”€â”€
# ĞĞ±Ñ€Ğ°Ñ‚Ğ¸Ñ‚Ğµ Ğ²Ğ½Ğ¸Ğ¼Ğ°Ğ½Ğ¸Ğµ: Ğ¸Ğ¼Ñ ÑĞµÑÑĞ¸Ğ¸ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ¾ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´Ğ°Ñ‚ÑŒ Ñ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ¼ user_session.session
client = TelegramClient('user_session', API_ID, API_HASH)
client.start()  # Ğ§Ğ¸Ñ‚Ğ°ĞµÑ‚ Ğ¸Ğ· user_session.session, Ğ½Ğ¸ĞºĞ°ĞºĞ¾Ğ³Ğ¾ Ñ‚Ğ¾ĞºĞµĞ½Ğ°

# â”€â”€â”€ ĞĞ‘Ğ ĞĞ‘ĞĞ¢Ğ§Ğ˜Ğš /start â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
@client.on(events.NewMessage(pattern=r'^/start$'))
async def start_handler(event):
    await event.reply(
        "ĞŸÑ€Ğ¸Ğ²ĞµÑ‚! Ğ¯ User-Ğ±Ğ¾Ñ‚, Ğ¼Ğ¾Ğ³Ñƒ ÑĞ¾Ğ±Ñ€Ğ°Ñ‚ÑŒ Ğ¿ÑƒĞ±Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğµ.\n"
        "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹: /info <username_or_link>"
    )

# â”€â”€â”€ Ğ¤Ğ£ĞĞšĞ¦Ğ˜Ğ¯ Ğ¡Ğ‘ĞĞ Ğ Ğ˜ĞĞ¤ĞĞ ĞœĞĞ¦Ğ˜Ğ˜ Ğ USER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def fetch_user_info(u: User):
    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¿Ğ¾Ğ»Ğ½ÑƒÑ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ
    full = await client(GetFullUserRequest(u.id))
    data = getattr(full, 'full_user', full)

    # Ğ¡Ğ¾Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ Ğ¿Ğ¾Ğ»Ñ
    return {
        'id':           u.id,
        'username':     u.username or 'â€”',
        'name':         f"{u.first_name or ''} {u.last_name or ''}".strip() or 'â€”',
        'is_bot':       u.bot,
        'is_verified':  bool(getattr(data, 'bot_info', None)),
        'status':       str(u.status or ''),
        'about':        getattr(data, 'about', '') or 'â€”',
        'about_len':    len(getattr(data, 'about', '') or ''),
        'photos_count': (await client.get_profile_photos(u, limit=0)).total,
        'common_chats': getattr(data, 'common_chats_count', 0),
    }

# â”€â”€â”€ ĞĞ‘Ğ ĞĞ‘ĞĞ¢Ğ§Ğ˜Ğš /info â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
@client.on(events.NewMessage(pattern=r'/info(?: |$)(.+)'))
async def info_handler(event):
    target = event.pattern_match.group(1).strip()
    if target.startswith('http'):
        target = target.rstrip('/').split('/')[-1]

    try:
        ent = await client.get_entity(target)
    except UsernameNotOccupiedError:
        return await event.reply("âŒ ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½.")
    except Exception as e:
        return await event.reply(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ¸ÑĞºĞµ: {e}")

    if not isinstance(ent, User):
        return await event.reply("â— Ğ­Ñ‚Ğ¾ Ğ½Ğµ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚. Ğ¯ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ñ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ñ Ñ„Ğ¸Ğ·Ğ»Ğ¸Ñ†Ğ°Ğ¼Ğ¸.")

    msg = await event.reply("ğŸ” Ğ¡Ğ¾Ğ±Ğ¸Ñ€Ğ°Ñ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµâ€¦")
    try:
        info = await fetch_user_info(ent)
    except Exception as e:
        return await msg.edit(f"âŒ ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ: {e}")

    text = "ğŸ“Š Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğµ:\n" + "\n".join(
        f"â€¢ {k}: {v}" for k, v in info.items()
    )
    await msg.edit(text)

# â”€â”€â”€ Ğ—ĞĞŸĞ£Ğ¡Ğš Ğ‘ĞĞ¢Ğ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def main():
    # Ğ—Ğ°Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ HTTP-ping
    threading.Thread(target=run_http, daemon=True).start()
    print("User-Ğ±Ğ¾Ñ‚ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½â€¦")
    client.run_until_disconnected()

if __name__ == '__main__':
    main()
